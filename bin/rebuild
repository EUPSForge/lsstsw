#!/bin/bash
#
# ********** DONT RUN THIS UNLESS YOU UNDERSTAND WHAT IT DOES ********
# **********             SERIOUS DAMAGE MAY OCCUR             ********
#
# Recursively build all product, starting with top-level ones listed in
# $PRODUCTS.
#
# The versiondb repository should be cloned from:
#
#   git@git.lsstcorp.org/LSST/DMS/devenv/versiondb.git
#
# For creation, use:
#
# 	(mkdir versiondb; cd versiondb; git init; mkdir dep_db ver_db manifests)
#

set -e
DIR=$(cd "$(dirname "$0")"; pwd -P)
. $DIR/../etc/settings.cfg.sh

usage() { echo "Usage: $0 [-p] [-r <ref> [-r <ref2> [...]]] [-t <eupstag>] [product1 [product2 [...]]]" 1>&2; exit 1; }

while getopts ":pr:t:" o; do
	case "$o" in
	p)
		PREP_ONLY=1
		;;
	r)
		REF="$REF --ref $OPTARG"
		;;
	t)
		TAG="$OPTARG"
		;;
	*)
		usage
		;;
	esac
done
shift $((OPTIND-1))

if [[ "$#" != "0" ]]; then
	PRODUCTS="$@"
fi

#echo REF=$REF
#echo PREP_ONLY=$PREP_ONLY
#echo TAG=$TAG
#echo PRODUCTS=$PRODUCTS

LOCKFILE_PREFIX="$DIR/../var/run/rebuild"
lock_mutex()
{
	# return failure if a lock cannot be attained

	if hash flock 2>/dev/null; then		# Prefer flock, if exists
		flock -w 0 200 || return
	elif hash lockfile 2>/dev/null; then	# Fall back to lockfile
		# note: yes, there's a race condition here -- if the process
		# is killed after lockfile succeeds but before trap runs, the
		# lockfile will remain dangling. I couldn't think of a simple way
		# to avoid it.
		lockfile -r 0 "$LOCKFILE_PREFIX.lock" 2>/dev/null || return
		trap "{ rm -f \"$LOCKFILE_PREFIX\".lock; }" EXIT
	else
		echo "don't know how to do locking on your system (neither flock or lockfile are available)." 1>&2
		echo "playing it safe and aborting." 1>&2
		exit -1
	fi
}

(
	lock_mutex || { echo "a rebuild is already in process." 1>&2; exit -1; }

	#
	# Prepare build
	#
	VERSIONDBHEAD=$(cd "$VERSIONDB" && git rev-parse HEAD)
	[[ -z $NOPUSH ]] && (cd "$VERSIONDB" && git pull --quiet)
	lsst-build prepare --exclusion-map="$EXCLUSIONS" --version-git-repo="$VERSIONDB" "$BUILDDIR" $PRODUCTS $REF
	[[ -z $NOPUSH && "$VERSIONDBHEAD" != $(cd "$VERSIONDB" && git rev-parse HEAD) ]] && (cd "$VERSIONDB" && git push && git push --tags)

	eval "$(grep -E '^BUILD=' "$BUILDDIR"/manifest.txt)"
	echo "# BUILD ID: $BUILD"

	if [[ "$PREP_ONLY" == 1 ]]; then
		exit
	fi

	#
	# Execute build
	#
	lsst-build build "$BUILDDIR"

	#
	# Tag as requested
	#
	if [[ ! -z $TAG ]]; then
		eups-copy-tag $BUILD $TAG
	fi

	echo "# BUILD $BUILD completed."
) 200>"$LOCKFILE_PREFIX.run"
